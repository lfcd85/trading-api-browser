/* tslint:disable */
/* eslint-disable */
/**
 * Client Portal Web API
 * Client Poral Web API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import {
  InlineObject2,
  InlineObject2FromJSON,
  InlineObject2ToJSON,
  InlineResponse2001,
  InlineResponse2001FromJSON,
  InlineResponse2001ToJSON,
  InlineResponse20010,
  InlineResponse20010FromJSON,
  InlineResponse20010ToJSON,
  InlineResponse2007,
  InlineResponse2007FromJSON,
  InlineResponse2007ToJSON,
  InlineResponse2008,
  InlineResponse2008FromJSON,
  InlineResponse2008ToJSON,
  InlineResponse2009,
  InlineResponse2009FromJSON,
  InlineResponse2009ToJSON,
  OrderData,
  OrderDataFromJSON,
  OrderDataToJSON,
  PositionData,
  PositionDataFromJSON,
  PositionDataToJSON,
} from "../models";

export interface CcpAuthInitPostRequest {
  compete?: boolean;
  locale?: string;
  mac?: string;
  machineId?: string;
  username?: string;
}

export interface CcpAuthResponsePostRequest {
  auth?: InlineObject2;
}

export interface CcpOrderDeleteRequest {
  acct: string;
  id: number;
}

export interface CcpOrderPostRequest {
  acct: string;
  conid: number;
  ccy: CcpOrderPostCcyEnum;
  exchange: CcpOrderPostExchangeEnum;
  qty: number;
  type?: CcpOrderPostTypeEnum;
  side?: CcpOrderPostSideEnum;
  price?: number;
  tif?: CcpOrderPostTifEnum;
}

export interface CcpOrderPutRequest {
  acct: string;
  id: number;
}

export interface CcpOrdersGetRequest {
  acct: string;
  cancelled?: boolean;
}

export interface CcpTradesGetRequest {
  from?: string;
  to?: string;
}

/**
 *
 */
export class CCPBetaApi extends runtime.BaseAPI {
  /**
   * Provides the list of tradeable accounts
   * Brokerage Accounts
   */
  async ccpAccountGetRaw(
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<InlineResponse2009>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/ccp/account`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InlineResponse2009FromJSON(jsonValue)
    );
  }

  /**
   * Provides the list of tradeable accounts
   * Brokerage Accounts
   */
  async ccpAccountGet(
    initOverrides?: RequestInit
  ): Promise<InlineResponse2009> {
    const response = await this.ccpAccountGetRaw(initOverrides);
    return await response.value();
  }

  /**
   * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
   * Start CCP Session
   */
  async ccpAuthInitPostRaw(
    requestParameters: CcpAuthInitPostRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<InlineResponse2001>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters.compete !== undefined) {
      formParams.append("compete", requestParameters.compete as any);
    }

    if (requestParameters.locale !== undefined) {
      formParams.append("locale", requestParameters.locale as any);
    }

    if (requestParameters.mac !== undefined) {
      formParams.append("mac", requestParameters.mac as any);
    }

    if (requestParameters.machineId !== undefined) {
      formParams.append("machineId", requestParameters.machineId as any);
    }

    if (requestParameters.username !== undefined) {
      formParams.append("username", requestParameters.username as any);
    }

    const response = await this.request(
      {
        path: `/ccp/auth/init`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InlineResponse2001FromJSON(jsonValue)
    );
  }

  /**
   * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
   * Start CCP Session
   */
  async ccpAuthInitPost(
    requestParameters: CcpAuthInitPostRequest,
    initOverrides?: RequestInit
  ): Promise<InlineResponse2001> {
    const response = await this.ccpAuthInitPostRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Session Token Authentication
   * Complete CCP Session
   */
  async ccpAuthResponsePostRaw(
    requestParameters: CcpAuthResponsePostRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<InlineResponse2007>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/ccp/auth/response`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: InlineObject2ToJSON(requestParameters.auth),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InlineResponse2007FromJSON(jsonValue)
    );
  }

  /**
   * Session Token Authentication
   * Complete CCP Session
   */
  async ccpAuthResponsePost(
    requestParameters: CcpAuthResponsePostRequest,
    initOverrides?: RequestInit
  ): Promise<InlineResponse2007> {
    const response = await this.ccpAuthResponsePostRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only)
   * Delete Order
   */
  async ccpOrderDeleteRaw(
    requestParameters: CcpOrderDeleteRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<OrderData>> {
    if (
      requestParameters.acct === null ||
      requestParameters.acct === undefined
    ) {
      throw new runtime.RequiredError(
        "acct",
        "Required parameter requestParameters.acct was null or undefined when calling ccpOrderDelete."
      );
    }

    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling ccpOrderDelete."
      );
    }

    const queryParameters: any = {};

    if (requestParameters.acct !== undefined) {
      queryParameters["acct"] = requestParameters.acct;
    }

    if (requestParameters.id !== undefined) {
      queryParameters["id"] = requestParameters.id;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/ccp/order`,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      OrderDataFromJSON(jsonValue)
    );
  }

  /**
   * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only)
   * Delete Order
   */
  async ccpOrderDelete(
    requestParameters: CcpOrderDeleteRequest,
    initOverrides?: RequestInit
  ): Promise<OrderData> {
    const response = await this.ccpOrderDeleteRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Submits an Order.
   * Submit Order
   */
  async ccpOrderPostRaw(
    requestParameters: CcpOrderPostRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<OrderData>> {
    if (
      requestParameters.acct === null ||
      requestParameters.acct === undefined
    ) {
      throw new runtime.RequiredError(
        "acct",
        "Required parameter requestParameters.acct was null or undefined when calling ccpOrderPost."
      );
    }

    if (
      requestParameters.conid === null ||
      requestParameters.conid === undefined
    ) {
      throw new runtime.RequiredError(
        "conid",
        "Required parameter requestParameters.conid was null or undefined when calling ccpOrderPost."
      );
    }

    if (requestParameters.ccy === null || requestParameters.ccy === undefined) {
      throw new runtime.RequiredError(
        "ccy",
        "Required parameter requestParameters.ccy was null or undefined when calling ccpOrderPost."
      );
    }

    if (
      requestParameters.exchange === null ||
      requestParameters.exchange === undefined
    ) {
      throw new runtime.RequiredError(
        "exchange",
        "Required parameter requestParameters.exchange was null or undefined when calling ccpOrderPost."
      );
    }

    if (requestParameters.qty === null || requestParameters.qty === undefined) {
      throw new runtime.RequiredError(
        "qty",
        "Required parameter requestParameters.qty was null or undefined when calling ccpOrderPost."
      );
    }

    const queryParameters: any = {};

    if (requestParameters.acct !== undefined) {
      queryParameters["acct"] = requestParameters.acct;
    }

    if (requestParameters.conid !== undefined) {
      queryParameters["conid"] = requestParameters.conid;
    }

    if (requestParameters.ccy !== undefined) {
      queryParameters["ccy"] = requestParameters.ccy;
    }

    if (requestParameters.exchange !== undefined) {
      queryParameters["exchange"] = requestParameters.exchange;
    }

    if (requestParameters.qty !== undefined) {
      queryParameters["qty"] = requestParameters.qty;
    }

    if (requestParameters.type !== undefined) {
      queryParameters["type"] = requestParameters.type;
    }

    if (requestParameters.side !== undefined) {
      queryParameters["side"] = requestParameters.side;
    }

    if (requestParameters.price !== undefined) {
      queryParameters["price"] = requestParameters.price;
    }

    if (requestParameters.tif !== undefined) {
      queryParameters["tif"] = requestParameters.tif;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/ccp/order`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      OrderDataFromJSON(jsonValue)
    );
  }

  /**
   * Submits an Order.
   * Submit Order
   */
  async ccpOrderPost(
    requestParameters: CcpOrderPostRequest,
    initOverrides?: RequestInit
  ): Promise<OrderData> {
    const response = await this.ccpOrderPostRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order.
   * Update Order
   */
  async ccpOrderPutRaw(
    requestParameters: CcpOrderPutRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<OrderData>> {
    if (
      requestParameters.acct === null ||
      requestParameters.acct === undefined
    ) {
      throw new runtime.RequiredError(
        "acct",
        "Required parameter requestParameters.acct was null or undefined when calling ccpOrderPut."
      );
    }

    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling ccpOrderPut."
      );
    }

    const queryParameters: any = {};

    if (requestParameters.acct !== undefined) {
      queryParameters["acct"] = requestParameters.acct;
    }

    if (requestParameters.id !== undefined) {
      queryParameters["id"] = requestParameters.id;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/ccp/order`,
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      OrderDataFromJSON(jsonValue)
    );
  }

  /**
   * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order.
   * Update Order
   */
  async ccpOrderPut(
    requestParameters: CcpOrderPutRequest,
    initOverrides?: RequestInit
  ): Promise<OrderData> {
    const response = await this.ccpOrderPutRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get status for all orders
   * Order Status
   */
  async ccpOrdersGetRaw(
    requestParameters: CcpOrdersGetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<InlineResponse20010>> {
    if (
      requestParameters.acct === null ||
      requestParameters.acct === undefined
    ) {
      throw new runtime.RequiredError(
        "acct",
        "Required parameter requestParameters.acct was null or undefined when calling ccpOrdersGet."
      );
    }

    const queryParameters: any = {};

    if (requestParameters.acct !== undefined) {
      queryParameters["acct"] = requestParameters.acct;
    }

    if (requestParameters.cancelled !== undefined) {
      queryParameters["cancelled"] = requestParameters.cancelled;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/ccp/orders`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InlineResponse20010FromJSON(jsonValue)
    );
  }

  /**
   * Get status for all orders
   * Order Status
   */
  async ccpOrdersGet(
    requestParameters: CcpOrdersGetRequest,
    initOverrides?: RequestInit
  ): Promise<InlineResponse20010> {
    const response = await this.ccpOrdersGetRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * List of positions
   * Positions
   */
  async ccpPositionsGetRaw(
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<PositionData>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/ccp/positions`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PositionDataFromJSON(jsonValue)
    );
  }

  /**
   * List of positions
   * Positions
   */
  async ccpPositionsGet(initOverrides?: RequestInit): Promise<PositionData> {
    const response = await this.ccpPositionsGetRaw(initOverrides);
    return await response.value();
  }

  /**
   * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
   * CCP Status
   */
  async ccpStatusGetRaw(
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<InlineResponse2008>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/ccp/status`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InlineResponse2008FromJSON(jsonValue)
    );
  }

  /**
   * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
   * CCP Status
   */
  async ccpStatusGet(initOverrides?: RequestInit): Promise<InlineResponse2008> {
    const response = await this.ccpStatusGetRaw(initOverrides);
    return await response.value();
  }

  /**
   * Get a list of Trades, by default, the list is from today midnight to Date.now().
   * Trades
   */
  async ccpTradesGetRaw(
    requestParameters: CcpTradesGetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<InlineResponse20010>> {
    const queryParameters: any = {};

    if (requestParameters.from !== undefined) {
      queryParameters["from"] = requestParameters.from;
    }

    if (requestParameters.to !== undefined) {
      queryParameters["to"] = requestParameters.to;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/ccp/trades`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InlineResponse20010FromJSON(jsonValue)
    );
  }

  /**
   * Get a list of Trades, by default, the list is from today midnight to Date.now().
   * Trades
   */
  async ccpTradesGet(
    requestParameters: CcpTradesGetRequest,
    initOverrides?: RequestInit
  ): Promise<InlineResponse20010> {
    const response = await this.ccpTradesGetRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }
}

/**
 * @export
 * @enum {string}
 */
export enum CcpOrderPostCcyEnum {
  Usd = "USD",
  Gbp = "GBP",
  Eur = "EUR",
}
/**
 * @export
 * @enum {string}
 */
export enum CcpOrderPostExchangeEnum {
  Nyse = "NYSE",
  Cboe = "CBOE",
  Nymex = "NYMEX",
}
/**
 * @export
 * @enum {string}
 */
export enum CcpOrderPostTypeEnum {
  Limit = "limit",
  Market = "market",
}
/**
 * @export
 * @enum {string}
 */
export enum CcpOrderPostSideEnum {
  Sell = "sell",
  Buy = "buy",
}
/**
 * @export
 * @enum {string}
 */
export enum CcpOrderPostTifEnum {
  Ioc = "IOC",
  Gtc = "GTC",
}
